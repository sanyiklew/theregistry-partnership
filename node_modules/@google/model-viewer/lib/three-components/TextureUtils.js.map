{"version":3,"file":"TextureUtils.js","sourceRoot":"","sources":["../../src/three-components/TextureUtils.js"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Cache, CubeTexture, EventDispatcher, GammaEncoding, NearestFilter, RGBEEncoding, TextureLoader} from 'three';\n\nimport EquirectangularToCubeGenerator from '../third_party/three/EquirectangularToCubeGenerator.js';\nimport PMREMCubeUVPacker from '../third_party/three/PMREMCubeUVPacker.js';\nimport PMREMGenerator from '../third_party/three/PMREMGenerator.js';\nimport RGBELoader from '../third_party/three/RGBELoader.js';\n\nimport EnvironmentMapGenerator from './EnvironmentMapGenerator.js';\n\n// Enable three's loader cache so we don't create redundant\n// Image objects to decode images fetched over the network.\nCache.enabled = true;\n\nconst HDR_FILE_RE = /\\.hdr$/;\nconst ldrLoader = new TextureLoader();\nconst hdrLoader = new RGBELoader();\n\nconst $cubeGenerator = Symbol('cubeGenerator');\n\nconst defaultConfig = {\n  cubemapSize: 1024,\n};\n\n// Attach a `userData` object for arbitrary data on textures that\n// originate from TextureUtils, similar to Object3D's userData,\n// for help debugging, providing metadata for tests, and semantically\n// describe the type of texture within the context of this application.\nconst userData = {\n  url: null,\n  // 'Equirectangular', 'Cube', 'PMREM'\n  mapping: null,\n};\n\nexport default class TextureUtils extends EventDispatcher {\n  /**\n   * @param {THREE.WebGLRenderer} renderer\n   * @param {?number} config.cubemapSize\n   */\n  constructor(renderer, config = {}) {\n    super();\n    this.config = {...defaultConfig, ...config};\n    this.renderer = renderer;\n    this.environmentMapGenerator = new EnvironmentMapGenerator(this.renderer);\n    this[$cubeGenerator] = null;\n  }\n\n  /**\n   * @param {THREE.Texture} texture\n   * @return {THREE.WebGLRenderCubeTarget}\n   */\n  equirectangularToCubemap(texture) {\n    const generator = new EquirectangularToCubeGenerator(texture, {\n      resolution: this.config.cubemapSize,\n    });\n\n    generator.update(this.renderer);\n\n    generator.renderTarget.texture.userData = {\n      ...userData,\n      ...({\n        url: texture.userData ? texture.userData.url : null,\n        mapping: 'Cube',\n      })\n    };\n\n    // It's up to the previously served texture to dispose itself,\n    // and therefore the generator's render target.\n    this[$cubeGenerator] = generator;\n\n    return generator.renderTarget;\n  }\n\n  /**\n   * @param {string} url\n   * @param {Function} progressCallback\n   * @return {Promise<THREE.Texture>}\n   */\n  async load(url, progressCallback = () => {}) {\n    try {\n      const isHDR = HDR_FILE_RE.test(url);\n      const loader = isHDR ? hdrLoader : ldrLoader;\n      const texture = await new Promise(\n          (resolve, reject) => loader.load(url, resolve, (event) => {\n            progressCallback(event.loaded / event.total * 0.9);\n          }, reject));\n\n      progressCallback(1.0);\n\n      texture.userData = {\n        ...userData,\n        ...({\n          url: url,\n          mapping: 'Equirectangular',\n        })\n      };\n\n      if (isHDR) {\n        texture.encoding = RGBEEncoding;\n        texture.minFilter = NearestFilter;\n        texture.magFilter = NearestFilter;\n        texture.flipY = true;\n      } else {\n        texture.encoding = GammaEncoding;\n      }\n\n      return texture;\n\n    } finally {\n      if (progressCallback) {\n        progressCallback(1);\n      }\n    }\n  }\n\n  /**\n   * @param {string} url\n   * @param {Function} progressCallback\n   * @return {Promise<THREE.WebGLRenderCubeTarget>}\n   */\n  async loadEquirectAsCubeMap(url, progressCallback = () => {}) {\n    let equirect = null;\n\n    try {\n      equirect = await this.load(url, progressCallback);\n      return await this.equirectangularToCubemap(equirect);\n    } finally {\n      if (equirect != null) {\n        equirect.dispose();\n      }\n    }\n  }\n\n  /**\n   * Returns a { skybox, environmentMap } object with the targets/textures\n   * accordingly. `skybox` is a WebGLRenderCubeTarget, and `environmentMap`\n   * is a Texture from a WebGLRenderCubeTarget.\n   *\n   * @see equirectangularToCubemap with regard to the THREE types.\n   * @param {string} url\n   * @param {boolean} config.pmrem\n   * @param {ProgressTracker} config.progressTracker\n   * @return {Promise<Object|null>}\n   */\n  async generateEnvironmentMapAndSkybox(\n      skyboxUrl = null, environmentMapUrl = null, options = {}) {\n    const {progressTracker} = options;\n    let updateGenerationProgress = () => {};\n\n    let skyboxLoads = Promise.resolve(null);\n    let environmentMapLoads = Promise.resolve(null);\n\n    let skybox = null;\n    let environmentMap = null;\n\n    try {\n      let environmentMapWasGenerated = false;\n\n      // If we have a specific environment URL, attempt to load it as a cubemap\n      // The case for this is that the user intends for the IBL to be different\n      // from the scene background (which may be a skybox or solid color).\n      if (!!environmentMapUrl) {\n        environmentMapLoads = this.loadEquirectAsCubeMap(\n            environmentMapUrl,\n            progressTracker ? progressTracker.beginActivity() : () => {});\n      }\n\n      // If we have a skybox URL, attempt to load it as a cubemap\n      if (!!skyboxUrl) {\n        skyboxLoads = this.loadEquirectAsCubeMap(\n            skyboxUrl,\n            progressTracker ? progressTracker.beginActivity() : () => {});\n      }\n\n      updateGenerationProgress =\n          progressTracker ? progressTracker.beginActivity() : () => {};\n\n      // In practice, this should be nearly as parallel as Promise.all (which\n      // we don't use since we can't easily destructure here):\n      environmentMap = await environmentMapLoads;\n      skybox = await skyboxLoads;\n\n      // If environment is still null, then no specific environment URL was\n      // specified\n      if (environmentMap != null) {\n        environmentMap = environmentMap.texture\n      } else {\n        if (skybox != null) {\n          // Infer the environment from the skybox if we have one:\n          environmentMap = skybox.texture;\n        } else {\n          // Otherwise, no skybox URL was specified, so fall back to generating\n          // the environment:\n          // TODO(#336): can cache this per renderer and color\n          environmentMap = this.environmentMapGenerator.generate();\n          environmentMapWasGenerated = true;\n        }\n      }\n\n      if (options.pmrem) {\n        // Apply the PMREM pass to the environment, which produces a distinct\n        // texture from the source:\n        const nonPmremEnvironmentMap = environmentMap;\n\n        environmentMap = this.pmremPass(nonPmremEnvironmentMap);\n\n        // If the source was generated, then we should dispose of it right away\n        if (environmentMapWasGenerated) {\n          nonPmremEnvironmentMap.dispose();\n        }\n      } else if (environmentMapWasGenerated) {\n        environmentMap.userData = {\n          ...userData,\n          ...({\n            mapping: 'Cube',\n          })\n        };\n      }\n\n      return {environmentMap, skybox};\n    } catch (error) {\n      if (skybox != null) {\n        skybox.dispose();\n      }\n\n      if (environmentMap != null) {\n        environmentMap.dispose();\n      }\n\n      throw error;\n    } finally {\n      updateGenerationProgress(1.0);\n    }\n  }\n\n  /**\n   * Takes a cube-ish (@see equirectangularToCubemap) texture and\n   * returns a texture of the prefiltered mipmapped radiance environment map\n   * to be used as environment maps in models.\n   *\n   * @param {THREE.Texture} texture\n   * @param {number} samples\n   * @param {number} resolution\n   * @return {THREE.Texture}\n   */\n  pmremPass(texture, samples, size) {\n    const generator = new PMREMGenerator(texture, samples, size);\n    generator.update(this.renderer);\n\n    const packer = new PMREMCubeUVPacker(generator.cubeLods);\n    packer.update(this.renderer);\n\n    const renderTarget = packer.CubeUVRenderTarget;\n\n    generator.dispose();\n    packer.dispose();\n\n    renderTarget.texture.userData = {\n      ...userData,\n      ...({\n        url: texture.userData ? texture.userData.url : null,\n        mapping: 'PMREM',\n      })\n    };\n\n    return renderTarget.texture;\n  }\n\n  dispose() {\n    // NOTE(cdata): In the case that the generators are invoked with\n    // an incorrect texture, the generators will throw when we attempt to\n    // dispose of them because the framebuffer has not been created yet but the\n    // implementation does not guard for this correctly:\n    try {\n      this.environmentMapGenerator.dispose();\n      this.environmentMapGenerator = null;\n      if (this[$cubeGenerator]) {\n        this[$cubeGenerator].dispose();\n        this[$cubeGenerator] = null;\n      }\n    } catch (_error) {\n    }\n  }\n}\n"]}